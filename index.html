<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Giao D·ªãch V√†ng Th·ªß C√¥ng</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body { font-family: Arial, sans-serif; background: #f8f9fa; padding: 20px; }
.container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
h1 { color: #d4af37; text-align: center; }
button { background: #d4af37; color: #222; border: none; padding: 10px 15px; margin: 5px; border-radius: 5px; font-weight: bold; cursor: pointer; }
button:hover { background: #e8c94d; }
button.danger { background: #f6465d; color: white; }
button.danger:hover { background: #ff6b81; }
button.close-single { background: #ff9500; color: white; margin-left: 5px; }
button.close-single:hover { background: #ffad33; }
input, select { padding: 6px 10px; border-radius: 4px; border: 1px solid #ccc; }
.trade-box { border-left: 5px solid #d4af37; padding: 10px; margin-top: 10px; border-radius: 6px; background: #fafafa; }
.trade-box.sell { border-left-color: #f6465d; }
.profit { color: #0ecb81; font-weight: bold; }
.loss { color: #f6465d; font-weight: bold; }
.price-display { text-align: center; font-size: 24px; color: #d4af37; margin: 20px 0; }
#historyList { max-height: 250px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; padding: 10px; }
.history-item { border-bottom: 1px solid #eee; padding: 5px 0; }
.sound-box { margin-top: 15px; background: #fafafa; border-radius: 6px; padding: 10px; border: 1px solid #ddd; }
</style>
</head>
<body>
<div class="container">
<h1>üí∞ Giao D·ªãch V√†ng Th·ªß C√¥ng (XAU/USD)</h1>

<div class="price-display">Gi√° hi·ªán t·∫°i: <span id="currentPrice">0.00</span></div>

<div>
  <label>S·ªë d∆∞: </label><span id="balanceText">1000.00</span> USD<br>
  <label>ƒê√≤n b·∫©y: </label><input type="number" id="leverage" value="10" min="1" max="100">
  <label>Lot: </label><input type="number" id="lotSize" value="0.1" step="0.01" min="0.01"><br>
  <label>Stop Loss (USD): </label><input type="number" id="stopLoss" value="50">
  <label>Take Profit (USD): </label><input type="number" id="takeProfit" value="65">
</div>

<div style="margin-top:10px;">
  <button onclick="openTrade('BUY')">üü© M·ªü L·ªánh BUY</button>
  <button class="danger" onclick="openTrade('SELL')">üü• M·ªü L·ªánh SELL</button>
  <button onclick="closeAllTrades()">‚ùå ƒê√≥ng T·∫•t C·∫£</button>
  <button class="danger" onclick="resetData()">üîÑ Reset D·ªØ Li·ªáu</button>
</div>

<div class="sound-box">
  <h3>üéµ √Çm Thanh Th√¥ng B√°o</h3>
  <label>Ch·ªçn file √¢m thanh:</label>
  <input type="file" id="soundFile" accept=".mp3">
</div>

<h3>üìä L·ªánh ƒêang M·ªü</h3>
<div id="activeTrades"></div>

<h3>üïí L·ªãch S·ª≠</h3>
<div id="historyList"></div>
</div>

<script>
const FINNHUB_API_KEY = 'd1l6t99r01qt4thebangd1l6t99r01qt4thebao0';
let ws, currentPrice = 0;
let trades = JSON.parse(localStorage.getItem('manualTrades')) || [];
let balance = parseFloat(localStorage.getItem('manualBalance')) || 1000;
let userSound = null;
let lastPriceTime = null, priceStagnantPlayed = false;

document.getElementById('balanceText').textContent = balance.toFixed(2);

// K·∫øt n·ªëi Finnhub WebSocket
function connectPrice() {
  ws = new WebSocket(`wss://ws.finnhub.io?token=${FINNHUB_API_KEY}`);
  ws.onopen = ()=> ws.send(JSON.stringify({type:'subscribe',symbol:'OANDA:XAU_USD'}));
  ws.onmessage = e => {
    const data = JSON.parse(e.data);
    if(data.type==='trade'){ 
      const p = data.data[data.data.length-1].p;
      currentPrice = p;
      document.getElementById('currentPrice').textContent = p.toFixed(2);
      lastPriceTime = Date.now();
      checkTrades();
      renderTrades(); // C·∫≠p nh·∫≠t l·ªùi/l·ªó theo gi√° hi·ªán t·∫°i
    }
  };
  ws.onclose = ()=> setTimeout(connectPrice,3000);
}
connectPrice();

// T√≠nh to√°n l·ªùi/l·ªó hi·ªán t·∫°i
function calculateCurrentProfit(trade) {
  if (trade.closed) return trade.profit;
  
  if (trade.type === 'BUY') {
    return (currentPrice - trade.entry) * trade.lot * trade.lev;
  } else {
    return (trade.entry - currentPrice) * trade.lot * trade.lev;
  }
}

// M·ªü l·ªánh
function openTrade(type){
  if(!currentPrice) return alert("Ch∆∞a c√≥ gi√°.");
  const lot = parseFloat(document.getElementById('lotSize').value);
  const lev = parseFloat(document.getElementById('leverage').value);
  const slAmount = parseFloat(document.getElementById('stopLoss').value);
  const tpAmount = parseFloat(document.getElementById('takeProfit').value);
  const entry = currentPrice;
  
  // T√≠nh SL v√† TP theo gi√° (t·ª´ USD)
  const stopLoss = type === 'BUY' ? entry - slAmount : entry + slAmount;
  const takeProfit = type === 'BUY' ? entry + tpAmount : entry - tpAmount;
  
  const trade = {
    id: Date.now(),
    type,
    entry,
    stopLoss,
    takeProfit,
    slAmount, // L∆∞u gi√° tr·ªã USD ƒë·ªÉ s·ª≠a sau n√†y
    tpAmount, // L∆∞u gi√° tr·ªã USD ƒë·ªÉ s·ª≠a sau n√†y
    lot, 
    lev, 
    openTime: new Date().toLocaleString('vi-VN'), 
    closed: false
  };
  
  trades.push(trade);
  saveData();
  renderTrades();
  playSound();
  addHistory(`M·ªü ${type} @ ${entry.toFixed(2)} | SL:${slAmount}USD | TP:${tpAmount}USD`);
}

// ƒê√≥ng l·ªánh
function closeTrade(trade, reason){
  const closePrice = currentPrice;
  const profit = calculateCurrentProfit(trade);
  balance += profit;
  trade.closed = true;
  trade.closePrice = closePrice;
  trade.closeTime = new Date().toLocaleString('vi-VN');
  trade.reason = reason;
  trade.profit = profit;
  playSound();
  addHistory(`ƒê√≥ng ${trade.type} @ ${closePrice.toFixed(2)} (${reason}) | <span class="${profit>=0?'profit':'loss'}">${profit.toFixed(2)} USD</span>`);
  saveData();
  renderTrades();
}

// ƒê√≥ng t·ª´ng l·ªánh th·ªß c√¥ng
function closeSingleTrade(id){
  const trade = trades.find(t => t.id === id && !t.closed);
  if(!trade) return;
  closeTrade(trade, 'ƒê√≥ng th·ªß c√¥ng');
}

// Ki·ªÉm tra SL/TP
function checkTrades(){
  trades.filter(t=>!t.closed).forEach(t=>{
    if(t.type==='BUY' && (currentPrice<=t.stopLoss || currentPrice>=t.takeProfit)){
      closeTrade(t, currentPrice<=t.stopLoss?'STOP LOSS':'TAKE PROFIT');
    }
    if(t.type==='SELL' && (currentPrice>=t.stopLoss || currentPrice<=t.takeProfit)){
      closeTrade(t, currentPrice>=t.stopLoss?'STOP LOSS':'TAKE PROFIT');
    }
  });
  checkPriceStill();
}

// C·∫£nh b√°o gi√° ƒë·ª©ng im
function checkPriceStill(){
  if(!lastPriceTime) return;
  if(Date.now()-lastPriceTime>15000 && !priceStagnantPlayed){
    playSound(); addHistory("‚ö†Ô∏è Gi√° kh√¥ng ƒë·ªïi 15s!");
    priceStagnantPlayed = true;
  }else if(Date.now()-lastPriceTime<=15000){
    priceStagnantPlayed=false;
  }
}

// S·ª≠a SL/TP theo USD
function editTrade(id){
  const t = trades.find(x=>x.id===id);
  if(!t) return;
  
  const slAmount = parseFloat(prompt("Nh·∫≠p StopLoss m·ªõi (USD):", t.slAmount || Math.abs(t.entry - t.stopLoss)));
  const tpAmount = parseFloat(prompt("Nh·∫≠p TakeProfit m·ªõi (USD):", t.tpAmount || Math.abs(t.entry - t.takeProfit)));
  
  if(!isNaN(slAmount)) {
    t.slAmount = slAmount;
    t.stopLoss = t.type === 'BUY' ? t.entry - slAmount : t.entry + slAmount;
  }
  if(!isNaN(tpAmount)) {
    t.tpAmount = tpAmount;
    t.takeProfit = t.type === 'BUY' ? t.entry + tpAmount : t.entry - tpAmount;
  }
  
  saveData(); 
  renderTrades();
  addHistory(`S·ª≠a l·ªánh ${t.type}: SL ${slAmount}USD, TP ${tpAmount}USD`);
}

// ƒê√≥ng t·∫•t c·∫£
function closeAllTrades(){
  trades.filter(t=>!t.closed).forEach(t=>closeTrade(t,'ƒê√≥ng tay'));
}

// Reset
function resetData(){
  if(!confirm("X√≥a t·∫•t c·∫£ d·ªØ li·ªáu?")) return;
  trades=[]; balance=1000;
  saveData(); renderTrades();
  document.getElementById('historyList').innerHTML="";
  addHistory("üîÑ Reset d·ªØ li·ªáu.");
}

// L∆∞u + render
function saveData(){
  localStorage.setItem('manualTrades', JSON.stringify(trades));
  localStorage.setItem('manualBalance', balance);
  document.getElementById('balanceText').textContent = balance.toFixed(2);
}

function renderTrades(){
  const box = document.getElementById('activeTrades');
  box.innerHTML="";
  
  trades.forEach(t=>{
    const currentProfit = calculateCurrentProfit(t);
    const div=document.createElement('div');
    div.className="trade-box "+(t.type==='SELL'?'sell':'');
    
    if(t.closed) {
      div.innerHTML=`
        <b>${t.type}</b> @ ${t.entry.toFixed(2)} 
        | ƒê√≥ng @ ${t.closePrice.toFixed(2)}<br>
        <span class="${t.profit>=0?'profit':'loss'}">${t.profit.toFixed(2)} USD</span> (${t.reason})
      `;
    } else {
      div.innerHTML=`
        <b>${t.type}</b> @ ${t.entry.toFixed(2)} 
        | SL:${t.stopLoss.toFixed(2)} (${t.slAmount}USD) | TP:${t.takeProfit.toFixed(2)} (${t.tpAmount}USD)<br>
        L·ªùi/L·ªó hi·ªán t·∫°i: <span class="${currentProfit>=0?'profit':'loss'}">${currentProfit.toFixed(2)} USD</span><br>
        <button onclick="editTrade(${t.id})">‚úèÔ∏è S·ª≠a SL/TP</button>
        <button class="close-single" onclick="closeSingleTrade(${t.id})">üî¥ ƒê√≥ng L·ªánh</button>
      `;
    }
    box.appendChild(div);
  });
}
renderTrades();

// L·ªãch s·ª≠
function addHistory(msg){
  const h=document.getElementById('historyList');
  const div=document.createElement('div');
  div.className="history-item";
  div.innerHTML=`${new Date().toLocaleTimeString('vi-VN')} - ${msg}`;
  h.prepend(div);
}

// √Çm thanh
document.getElementById('soundFile').addEventListener('change',e=>{
  const f=e.target.files[0];
  if(f){ userSound=new Audio(URL.createObjectURL(f)); addHistory("üéµ ƒê√£ ch·ªçn √¢m thanh."); }
});
function playSound(){ if(userSound){ userSound.currentTime=0; userSound.play().catch(()=>{}); } }

setInterval(checkPriceStill, 2000);
</script>
</body>
</html>